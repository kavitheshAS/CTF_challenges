# FAKE AZURE

## Source Code Analysis

The given `enchantment.py` script saves 719 random numbers into an output file and then concatenates the next 49 numbers as the lower bits of a prime.

```python
def brew_scrolls(seed, output_scroll,num_initial=719,num_predict=48):
    random.seed(seed)

    with open(output_scroll, 'w') as file:
        for index in range(num_initial):
            value = random.getrandbits(32)  
            unix_time = int(time.time())
            event="void"
            file.write(f"[{bin(index)[2:].zfill(10)}:{event}:{value}:{unix_time}]\n")

    values = [random.getrandbits(32) for _ in range(num_predict)]
    vtstr=""
    for index, val in enumerate(values, start=1):
        vstr=str(val)
        vtstr=vtstr+vstr
    fn=random.getrandbits(32)
    fne=str(fn)[:-2]
    vtstr+=fne
    return vtstr[:-9]
```

The `brew_primes` function generates two primes. One prime is generated by using the next 49 numbers as the lower bits of a prime, while the other prime is generated securely using the `secrets` module, which is cryptographically secure compared to the `random` module.

```python
def brew_primes(bitL):
    while True:
        num1 = result
        num2 = randbits(512)

        p = (num1<<512)+ num2

        if isprime(p):
            return num1, num2, p

bitL = 2025
while 2025:
    q=randbits(2025)
    if isprime(q):
        break
num1, num2, p = brew_primes(bitL)
```

### Goldwasser-Micali Cryptosystem

The flag is encrypted using a [Goldwasser-Micali](https://en.wikipedia.org/wiki/Goldwasser%E2%80%93Micali_cryptosystem) like cryptosystem with public key `N`. It can be decrypted given the factorization of `N`.

```python
x = randint(2025, n) 
while 2025:
    lp = legendre_symbol(x, p)
    lq = legendre_symbol(x, q)
    if lp * lq > 0 and lp + lq < 0:
        break
    x = randint(2025, n)

m = map(int, bin(bytes_to_long(flag))[2:])

binary_list = list(m)  

c = []
for b in binary_list:
    while 2025:
        r = randint(2025, n)
        if gcd(r, n) == 1:
            break
    c.append((pow(x, 2025 + b, n) * pow(r, 2025+2025, n)) % n)
```

The cryptosystem works by taking $N = pq$ to be the product of two large primes $p$ and $q$, and a random value $x$ such that

$$\left ( \dfrac{x}{p} \right ) = \left ( \dfrac{x}{q} \right ) = -1$$

i.e. such that $x$ is a quadratic non-residue modulo $p$ and a quadratic non-residue modulo $q$.

To encrypt a single bit $b$, a random value $1 \leq r < N$ is chosen such that $\gcd(r, N) = 1$, and the value $c \equiv r^2 x^b \pmod N$ is outputted. To encrypt a message, we encrypt all of its bits individually.

Note that if $b = 0$, then the outputted value $c$ will be a quadratic residue modulo $p$, hence, if we find that $c$ is a quadratic non-residue modulo $p$, then we will know that $b = 1$. Similarly, if $b = 1$, then the outputted value $c$ will be a quadratic non-residue modulo $p$. So if we find that $c$ is a quadratic residue modulo $p$, then we will know that $b = 0$.

Note that the flag is encrypted slightly different to the standard Goldwasser-Micali encryption. Here, the quadratic non-residue x is raised to the power of 2025 + b, so when b = 0, the result is a quadratic non-residue, and when b = 1, the result is a quadratic residue. This just means that if the ciphertext is a quadratic residue, then b = 1, and if it is a quadratic non-residue, then b = 0 . Also, the exponent for the random value r is 2025 + 2025, (purely for thematic purposes) it only matters that this value is even.

### Part 1: Breaking the PRNG

Analyzing the `out.log` file, it's evident that the third column contains a sequence of consecutive random numbers generated by Python’s `random` module, which is known to be cryptographically insecure. This is similar to the [PHP `mt_rand()`](https://www.ambionics.io/blog/php-mt-rand-prediction) function, which uses the Mersenne Twister algorithm.

The first step is to find the seed of the PRNG so that future values can be predicted. This [article](https://stackered.com/blog/python-random-prediction/#seed-recovery-from-few-outputs) explains how to break the PRNG by first untempering and then finding the seed.

#### PRNG Recovery Code

```python
def unshiftRight(x, shift):
    res = x
    for i in range(32):
        res = x ^ res >> shift
    return res


def unshiftLeft(x, shift, mask):
    res = x
    for i in range(32):
        res = x ^ (res << shift & mask)
    return res


def untemper(v):
    v = unshiftRight(v, 18)
    v = unshiftLeft(v, 15, 0xefc60000)
    v = unshiftLeft(v, 7, 0x9d2c5680)
    v = unshiftRight(v, 11)
    return v


def invertStep(si, si227):
    X = si ^ si227
    mti1 = (X & 0x80000000) >> 31
    if mti1:
        X ^= 0x9908b0df
    X <<= 1
    mti = X & 0x80000000
    mti1 += X & 0x7FFFFFFF
    return mti, mti1


def init_genrand(seed):
        MT = [0] * 624
        MT[0] = seed & 0xffffffff
        for i in range(1, 623+1): # loop over each element
            MT[i] = ((0x6c078965 * (MT[i-1] ^ (MT[i-1] >> 30))) + i) & 0xffffffff
        return MT


def recover_kj_from_Ji(ji, ji1, i):
    const = init_genrand(19650218)
    key = ji - (const[i] ^ ((ji1 ^ (ji1 >> 30))*1664525))
    key &= 0xffffffff
    return key


def recover_Ji_from_Ii(Ii, Ii1, i):
    ji = (Ii + i) ^ ((Ii1 ^ (Ii1 >> 30)) * 1566083941)
    ji &= 0xffffffff
    return ji


def recover_Kj_from_Ii(Ii, Ii1, Ii2, i):
   
    Ji = recover_Ji_from_Ii(Ii, Ii1, i)
    Ji1 = recover_Ji_from_Ii(Ii1, Ii2, i-1)
    return recover_kj_from_Ji(Ji, Ji1, i)


def rewindState(state):
    prev = [0]*624
    s = state[:]
    I, I0 = invertStep(s[623], s[396])
    prev[623] += I
    s[0] = (s[0]&0x80000000) + I0
    for i in range(227, 623):
        I, I1 = invertStep(s[i], s[i-227])
        prev[i] += I
        prev[i+1] += I1
    for i in range(227):
        I, I1 = invertStep(s[i], prev[i+397])
        prev[i] += I
        prev[i+1] += I1
    return prev


def seedArrayFromState(s, subtractIndices=True):
    s_ = [0]*624
    for i in range(623, 2, -1):
        s_[i] = recover_Ji_from_Ii(s[i], s[i-1], i)
    s_[0]=s_[623]
    s_[1]=recover_Ji_from_Ii(s[1], s[623],  1)
    s_[2]=recover_Ji_from_Ii(s[2], s_[1], 2)
    seed = [0]*624
    for i in range(623, 2, -1):
        seed[i-1] = recover_kj_from_Ji(s_[i], s_[i-1], i)
    seed[0] = 0
    s1_old = ((2194844435 ^ ((19650218 ^ (19650218 >> 30))*1664525))) & 0xffffffff
    seed[1] = recover_kj_from_Ji(s_[2], s1_old, 2)
    seed[623] = (s_[1] - (s1_old ^ ((s_[0] ^ (s_[0] >> 30))*1664525))) & 0xffffffff
    if subtractIndices:
        seed = [(2**32+e-i)%2**32 for i,e in enumerate(seed)]
    return seed


def seedArrayToInt(s):
    seed = 0
    for e in s[::-1]:
        seed += e
        seed <<= 32
    return seed >> 32
```

A script processes the log file to extract relevant values:

```python
input_file = 'scroll.log'      
output_file = 'scroll_ref.log'  

with open(input_file, 'r') as infile, open(output_file, 'w') as outfile:
    for line in infile:
        if '[' in line and ']' in line:
            content = line.split('[')[1].split(']')[0]
            values = content.split(':')
            if len(values) >= 3:
                third_value = values[2]
                outfile.write(third_value + '\n')

print(f"values saved to {output_file}.")
```

A further script is used to predict the next values:

```python
#!/usr/bin/env python3
from functions import untemper
import random

def recover_internal_state(outputs, start_index):
    # Recover the state starting from the required index
    state = [untemper(output) for output in outputs[start_index:start_index + 624]]
    
    # The state array should have 624 elements, and the index is set to 624.
    return (3, tuple(state + [624]), None)

def predict_next_values(recovered_state, num_predictions):
    # Create a new Random instance and set its internal state
    PRNG = random.Random()
    PRNG.setstate(recovered_state)
    
    # Generate the next num_predictions values
    return [PRNG.getrandbits(32) for _ in range(num_predictions+1)]

def main():
    # Read the outputs from the file
    with open('../includes/scroll_ref.log', 'r') as file:
        outputs = [int(line.strip()) for line in file.readlines()]
    
    # Index to start recovering the state (719th number corresponds to index 718 in a 0-based index)
    start_index = 718 - 624 + 1  # Offset by 624 to have enough outputs for state recovery
    if start_index < 0:
        raise ValueError("Insufficient outputs in the file to predict from the 719th number.")
    
    # Recover the internal state
    recovered_state = recover_internal_state(outputs, start_index)
    print("Internal state recovered successfully.")
    
    num_predictions=48
    
    # Predict the values
    predictions = predict_next_values(recovered_state, num_predictions)
    print(f"Next {num_predictions} PRNG values starting from the 719th number:")
    for value in predictions:
        print(value)
    vtstr=""
    for index, val in enumerate(predictions, start=1):
        vstr=str(val)
        vtstr=vtstr+vstr
        print(f"{index}: {val}")
    print(vtstr[:-11])
    
if __name__ == "__main__":
    main()
```

### Part 2: Finding the Prime Factors of N via Coppersmith's Attack

To decrypt the ciphertext, we need the prime factorization of `N`. Since part of the prime factor `p` is generated using the PRNG, the remaining bits can be found using Coppersmith’s method, a classic case of [Coppersmith's Attack](https://en.wikipedia.org/wiki/Coppersmith%27s_attack). More details on the algorithm can be found [here](https://cryptohack.gitbook.io/cryptobook/lattices/applications/coppersmith-algorithm).

#### Coppersmith's Attack Implementation

```python
import random
from sympy import nextprime

def long_to_bytes(n):
    return n.to_bytes((n.bit_length() + 7) // 8, 'big')

#result from breaking PRNG and n  in out.txt
result=...
n = ...
c= ....

p_approx = (result << 512)

P.<x> = PolynomialRing(Zmod(n))
f = x + p_approx

X = 2**513        
beta = 0.3
epsilon = 0.04  

d = f.small_roots(X=X, beta=beta, epsilon=epsilon, algorithms=['chen'])
if d:
    p = p_approx + d[0]
    print('\nrecovered p:', p)
else:
    print("\nFailed to find roots")
    
#is from out.txt

flag = ''.join('0' if kronecker(x, p) == -1 else '1' for x in c)
print('[*] Raw binary flag:', flag)
flag = long_to_bytes(int(flag, 2))
print('[*] flag:', flag.decode())
```

Once `p` and `q` are recovered, decryption is straightforward:

```bash
recovered p: 5643102010236315124409452260830682546334133489046869948025973923745994277383482901831496605506148654600149688592668781483187037630677557052307342917447073562568200389439288219615586427664342594192125092631714330657158388232305233744221577763233993191992682908171538820199860734442933169973198135235183135152203729767103307894333380486504937111452562340445593092898614661266215915092346484632261384653360526676281992657724084825507463723407695555229662915138865633344563137698816552227199653315030392412515149957905074320416252344585331180213907645489380149326331679857151464745854613441913013384596873692225481323598194331
[*] Raw binary flag: 1110000010111110110001101110100011001100111101101001111001100000011000001101000010111110111011100110100001100010111010001011111011000110110111100110000011100000011001101110010011100110110110100110001011101000110100001011111011101110011000001110010011010110011001100110100010111110111001000110011001101000011000100110001011110010010000101111101
[*] flag: p_ctf{O00h_w41t_co0p3rsm1th_w0rk34_r3411y!}
```
