import subprocess
import re
import hashlib
from hashlib import sha1


j = 201 #value of j shud be (1+val in range)

def inverse_mod(a, m):
    if m <= 0:
        raise ValueError("Modulus must be positive")
    
    # Handle negative input
    a = a % m
    
    # Extended Euclidean algorithm
    def extended_gcd(a, b):
        if a == 0:
            return b, 0, 1
        gcd, x1, y1 = extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        return gcd, x, y
    
    gcd, x, _ = extended_gcd(a, m)
    
    if gcd != 1:
        raise ValueError(f"Modular inverse does not exist for {a} (mod {m})")
    
    return x % m

process = subprocess.Popen(
    ["python3", "server_obf.py"],  # Replace with your target script name
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True  # Ensures text mode for easier string handling
)
replies=list(range(j))  
message_sent=[]
inputs=list(range(j))


process.stdin.flush() 
output=process.stdout.readline()
print(f"op1:{output}")
process.stdin.flush() 
output=process.stdout.readline()
print(f"op2:{output}")
process.stdin.write(f"1\n")
process.stdin.flush()
output=process.stdout.readline()
print(f"op3:{output}")
process.stdin.write("0\n")
process.stdin.flush()
replies[0]=process.stdout.readline()
print(replies[0])
for i in range(1,j):
    process.stdin.flush() 
    output=process.stdout.readline()
    process.stdin.flush() 
    output=process.stdout.readline()
    process.stdin.write(f"1\n")
    process.stdin.flush()
    output=process.stdout.readline()
    process.stdin.write(f"{inputs[i]}\n")
    process.stdin.flush()
    replies[i]=process.stdout.readline()
    
hex_pattern=r"0x[0-9a-fA-F]+"
print(len(replies))
print(replies[0],replies[j-1])
print(inputs[0],inputs[j-1])
tuple_pattern = r"\('([0x0-9a-fA-F]+)', '([0x0-9a-fA-F]+)'\)"
match1 = re.search(tuple_pattern, replies[0])
match2 = re.search(tuple_pattern, replies[200])
if match1 and match2:
    rh = match1.group(1)  # Common value (First value in the tuple)
    s1h = match1.group(2)  # Second value in the first tuple
    s2h = match2.group(2)  # Second value in the second tuple

    print(f"rh = {rh}")
    print(f"s1h = {s1h}")
    print(f"s2h = {s2h}")
r=int(rh,16)
s1=int(s1h,16)
s2=int(s2h,16)

a, b  = 0, 7 
G = (55066263022277343669578718895168534326250603453777594175500187360389116729240,
     32670510020758816978083085130507043184471273380659243275938904335757337482424)
p = pow(2, 256) - pow(2, 32) - pow(2, 9) - pow(2, 8) - pow(2, 7) - pow(2, 6) - pow(2, 4) - pow(2, 0)
n = 115792089237316195423570985008687907852837564279074904382605163141518161494337


m1=str(inputs[0])
m2=str(inputs[j-1])

z1 = int(sha1(m1.encode()).hexdigest(), 16)
z2 = int(sha1(m2.encode()).hexdigest(), 16)

k_0=int((((z1-z2) % n)*inverse_mod(s1-s2,n))%n)
d=int(((((s1*k_0)%n)-z1)*inverse_mod(r,n))%n)
print(f"k_0:{k_0}")
print(f"d:{d}")


def add_points(P, Q, p):
    x1, y1 = P
    x2, y2 = Q
    if x1 == x2 and y1 == y2:
        beta = (3 * x1 * x2 + a) * pow((2 * y1), -1, p)
    else:
        beta = (y2 - y1) * pow((x2 - x1), -1, p)
    x3 = (pow(beta, 2) - x1 - x2) % p
    y3 = (beta * (x1 - x3) - y1) % p
    return x3, y3

def is_on_curve(P, p):
    x, y = P
    assert (y * y) % p == (pow(x, 3, p) + a * x + b) % p

is_on_curve(G, p)

def apply_double_and_add_method(G, k, p):
    target_point = G
    k_binary = bin(k)[2:]
    for i in range(1, len(k_binary)):
        current_bit = k_binary[i]
        target_point = add_points(target_point, target_point, p)
        if current_bit == '1':
            target_point = add_points(target_point, G, p)
    is_on_curve(target_point, p)
    return target_point
Q = apply_double_and_add_method(G=G, k=d, p=p)

random_point=apply_double_and_add_method(G=G, k=k_0, p=p)

r_e=(random_point[0])%n 
rh=hex(r_e)
message="give_me_signature"

hash_int = int(hashlib.sha1(message.encode()).hexdigest(),16)
s_e= int(((hash_int + r * d) * pow(k_0,-1, n)) % n)
sh=hex(s_e)

print(r_e,s_e)
process.stdin.flush()
output=process.stdout.readline()
print(output)
process.stdin.flush()
output=process.stdout.readline()
print(output)
process.stdin.write("2\n")
process.stdin.flush()
output=process.stdout.readline()
process.stdin.flush()
output=process.stdout.readline()
print(output)
process.stdin.flush()
output=process.stdout.readline()
print(output)
process.stdin.flush()
output=process.stdout.readline()
print(output)

process.stdin.write(f"{r_e}\n")
process.stdin.flush()
process.stdin.write(f"{s_e}\n")
process.stdin.flush()
output=process.stdout.readline()
print(output)
process.stdin.write("1\n")
process.stdin.flush()
output=process.stdout.readline()  
print(output)

process.terminate()